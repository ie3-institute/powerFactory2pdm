/*
 * Â© 2021. TU Dortmund University,
 * Institute of Energy Systems, Energy Efficiency and Energy Economics,
 * Research group Distribution grid planning and operation
 */

package edu.ie3.powerFactory2psdm.model

import com.typesafe.scalalogging.LazyLogging
import edu.ie3.powerFactory2psdm.config.ConversionConfigUtils.ParameterSource
import edu.ie3.powerFactory2psdm.converter.ConversionHelper
import edu.ie3.powerFactory2psdm.exception.pf.{
  ConversionException,
  GridConfigurationException,
  MissingParameterException
}
import edu.ie3.powerFactory2psdm.model.RawPfGridModel.{
  LineSections,
  LineTypes,
  Lines,
  Loads,
  LoadsLV,
  LoadsMV,
  Nodes,
  ProjectSettings,
  StatGen,
  Switches,
  TrafoTypes2w,
  Trafos2w
}
import edu.ie3.powerFactory2psdm.model.entity.{
  Line,
  LineSection,
  Load,
  Node,
  StaticGenerator,
  Switch,
  Transformer2W
}
import edu.ie3.powerFactory2psdm.model.entity.types.{
  LineType,
  Transformer2WType
}
import edu.ie3.powerFactory2psdm.model.setting.{ConversionPrefixes, UnitSystem}

/** Representation of the grid which is to be converted to a PSDM
  * [[edu.ie3.datamodel.models.input.container.GridContainer]]. The
  * preprocessing is done in order to unpack and check Optionals of the
  * [[RawPfGridModel]], check for duplicated ids as well as allow for building
  * inheritance relationships of all the custom classes of grid elements (e.g.
  * nodes, lines, generators) since these can not sensibly be actualized by the
  * [[SchemaGenerator]].
  *
  * @param nodes
  *   electrical nodes of the grid
  * @param lineTypes
  *   line types of the grid
  * @param lines
  *   electrical lines of the grid
  * @param switches
  *   electrical switches of the grid
  * @param transformerTypes2W
  *   two-winding transformer types
  * @param conversionPrefixes
  *   conversion prefixes for certain model parameters
  */
final case class PreprocessedPfGridModel(
    nodes: List[Node],
    lineTypes: List[LineType],
    lines: List[Line],
    switches: List[Switch],
    transformers2W: List[Transformer2W],
    transformerTypes2W: List[Transformer2WType],
    loads: List[Load],
    staticGenerators: List[StaticGenerator],
    conversionPrefixes: ConversionPrefixes
)

object PreprocessedPfGridModel extends LazyLogging {

  /** Builds the preprocessed grid model from the unprocessed generated grid
    * model.
    *
    * @param rawGrid
    *   the raw PowerFactory grid model as generated by the [[SchemaGenerator]]
    * @return
    *   the preprocessed PowerFactory grid model
    */
  def build(
      rawGrid: RawPfGridModel,
      sRatedSource: ParameterSource,
      cosPhiSource: ParameterSource
  ): PreprocessedPfGridModel = {
    val projectSettings = extractProjectSettings(rawGrid.projectSettings)
    checkUnitSystem(
      projectSettings.unitSystem.getOrElse(
        throw ConversionException(
          "There is no unit system defined."
        )
      )
    )
    val conversionPrefixes = buildConversionPrefixes(projectSettings)
    val rawNodes = rawGrid.nodes.getOrElse(
      throw GridConfigurationException("There are no nodes in the grid.")
    )
    val rawLines = rawGrid.lines.getOrElse({
      logger debug "There are no lines in the grid."
      List.empty[Lines]
    })
    val rawLineTypes = rawGrid.lineTypes.getOrElse({
      logger debug "There are no lines in the grid."
      List.empty[LineTypes]
    })
    val rawLineSections = rawGrid.lineSections.getOrElse({
      logger debug "There are no line sections in the grid."
      List.empty[LineSections]
    })
    val rawSwitches = rawGrid.switches.getOrElse({
      logger debug "There are no switches in the grid."
      List.empty[Switches]
    })
    val rawTrafos2W = rawGrid.trafos2w.getOrElse({
      logger debug "There are no switches in the grid."
      List.empty[Trafos2w]
    })
    val rawTrafoTpyes2W = rawGrid.trafoTypes2w.getOrElse({
      logger debug "There are no 2w trafo types in the grid."
      List.empty[TrafoTypes2w]
    })
    val rawLoads =
      (rawGrid.loads ++ rawGrid.loadsLV ++ rawGrid.loadsMV).flatten.toList
    if (rawLoads.isEmpty) logger debug "There are no loads in the grid."
    val rawStaticGenerators = rawGrid.statGen.getOrElse({
      logger debug "There are no static generators in the grid."
      List.empty[StatGen]
    })

    val models =
      rawNodes ++ rawLines ++ rawLineTypes ++ rawLineSections ++ rawSwitches ++ rawTrafos2W ++ rawTrafoTpyes2W ++ rawLoads ++ rawStaticGenerators
    val modelIds = models.map {
      case node: Nodes =>
        node.id.getOrElse(
          throw MissingParameterException(s"Node $node has no defined id")
        )
      case line: Lines =>
        line.id.getOrElse(
          throw MissingParameterException(s"Line $line has no defined id")
        )
      case lineType: LineTypes =>
        lineType.id.getOrElse(
          throw MissingParameterException(
            s"Line type $lineType has no defined id"
          )
        )
      case lineSection: LineSections =>
        lineSection.id.getOrElse(
          throw MissingParameterException(
            s"Line section $lineSection has no defined id"
          )
        )
      case switch: Switches =>
        switch.id.getOrElse(
          throw MissingParameterException(s"Switch $switch has no defined id")
        )
      case trafo2w: Trafos2w =>
        trafo2w.id.getOrElse(
          throw MissingParameterException(
            s"Transformer $trafo2w has no defined id"
          )
        )
      case trafoType2w: TrafoTypes2w =>
        trafoType2w.id.getOrElse(
          throw MissingParameterException(
            s"Transformer type $trafoType2w has no defined id"
          )
        )
      case load: Loads =>
        load.id.getOrElse(
          throw MissingParameterException(
            s"Load $load has no defined id"
          )
        )
      case load: LoadsLV =>
        load.id.getOrElse(
          throw MissingParameterException(
            s"LV load $load has no defined id"
          )
        )
      case load: LoadsMV =>
        load.id.getOrElse(
          throw MissingParameterException(
            s"MV load $load has no defined id"
          )
        )
      case staticGenerator: StatGen =>
        staticGenerator.id.getOrElse(
          throw MissingParameterException(
            s"Static generator $staticGenerator has no defined id"
          )
        )
    }
    val duplicateIds = ConversionHelper.getDuplicates(modelIds.toVector)
    if (duplicateIds.nonEmpty) {
      throw GridConfigurationException(
        s"Can't build grid as there are grid elements with duplicated ids: $duplicateIds"
      )
    }

    val duplicateUnsafeNodeIds =
      ConversionHelper.getDuplicates(rawNodes.map(_.locName).toVector)
    if (duplicateUnsafeNodeIds.nonEmpty) {
      logger.warn(
        s"There are the following duplicated unsafe node ids within the nodes: $duplicateUnsafeNodeIds. " +
          s"This leads to duplicated UUIDs if you supply an id to uuid mapping for the nodes."
      )
    }

    val nodes = rawNodes.map(Node.build)
    val lineSectionsMap = LineSection.buildLineSectionMap(rawLineSections)
    val lines = rawLines.map(line => Line.build(line, lineSectionsMap))
    val lineTypes = rawLineTypes.map(LineType.build)
    val switches = rawSwitches.flatMap(Switch.maybeBuild)
    val transformers2W = rawTrafos2W.map(Transformer2W.build)
    val trafoTypes2W = rawTrafoTpyes2W.map(Transformer2WType.build)
    val loads = rawLoads.map {
      case load: Loads   => Load.build(load, conversionPrefixes.loadPQSPrefix())
      case load: LoadsLV => Load.build(load)
      case load: LoadsMV => Load.build(load, conversionPrefixes.loadPQSPrefix())
      case other =>
        throw ConversionException(
          s"Encountered unexpected load type: $other. Processing of this load type is not supported."
        )
    }
    val staticGenerators = rawStaticGenerators.map(statGen =>
      StaticGenerator.build(statGen, sRatedSource, cosPhiSource)
    )

    PreprocessedPfGridModel(
      nodes,
      lineTypes,
      lines,
      switches,
      transformers2W,
      trafoTypes2W,
      loads,
      staticGenerators,
      conversionPrefixes
    )
  }

  private def extractProjectSettings(
      rawSettings: Option[List[ProjectSettings]]
  ): ProjectSettings = {
    rawSettings match {
      case Some(List(settings)) => settings
      case Some(List(_, _, _*)) =>
        throw ConversionException(
          "There are multiple project settings defined."
        )
      case None =>
        throw ConversionException("There are no project settings defined.")
    }
  }

  private def checkUnitSystem(unitSystem: Double): Unit = {
    unitSystem match {
      case UnitSystem.metric => ()
      case _ =>
        throw ConversionException(
          "Conversion is currently only implemented for the metric unit system"
        )
    }
  }

  private def buildConversionPrefixes(
      settings: ProjectSettings
  ): ConversionPrefixes = {
    ConversionPrefixes(
      settings.prefixPQS.getOrElse(
        throw MissingParameterException(
          "The projects settings miss the prefix specification for active/reactive/apparent power values"
        )
      ),
      settings.prefixLength.getOrElse(
        throw MissingParameterException(
          "The project settings miss the prefix specification for line length."
        )
      )
    )
  }
}
